<script type="text/javascript">
    RED.nodes.registerType('knxUltimate', {
        category: 'input',
        color: '#99ccff',
        defaults: {
            server: { type: "knxUltimate-config", required: true },
            topic: { value: "" },
            dpt: { value: "" },
            initialread: { value: false },
            notifyreadrequest: { value: false },
            notifyresponse: { value: false },
            notifywrite: { value: true },
            listenallga: { value: false },
            name: { value: "" },
            outputtype: { value: "write" },
            inputRBE: { value: false }
        },
        inputs: 1,
        outputs: 1,
        align: "left",
        icon: "knx.png",
        label: function () {
            return (this.inputRBE==true?"|rbe| ":"") + this.name || this.topic || "knx-ultimate"
        },
        oneditprepare: function () {
            $.getJSON('knxUltimateDpts', (data) => {
                data.forEach(dpt => {
                    $("#node-input-dpt").append($("<option></option>")
                        .attr("value", dpt.value)
                        .text(dpt.text))
                });
                $("#node-input-dpt").val(this.dpt)
            })

            // Add write and response as default for existing nodes like was default before
            if (typeof this.notifywrite === 'undefined') {
                this.notifywrite = true
                this.notifyresponse = true
                $("#node-input-notifywrite").prop("checked", true)
                $("#node-input-notifyresponse").prop("checked", true)
            }
           
              // Add Write as default for existing clients output
              if (typeof this.outputtype === 'undefined') {
                this.outputtype = "write"
                $("#node-input-outputtype").val("write")
            }

            $("#node-input-listenallga").on('change',function() {
                if ($("#node-input-listenallga").is(":checked")) {
                    $("#GAandDPT").hide()
                }else{
                    $("#GAandDPT").show()
                }
            })

           // Autocomplete suggestion with ETS csv File
            $( "#node-input-topic" ).autocomplete({
                minLength: 1,
                source: function( request, response ) {
                    //$.getJSON("csv", request, function( data, status, xhr ) {
                    $.getJSON("knxUltimatecsv", (data) => {
                        response($.map(data, function (value, key) {
                            var sSearch = (value.ga + " (" + value.devicename+") DPT"+value.dpt).toUpperCase();
                            if (sSearch.indexOf(request.term.toUpperCase()) != -1) {				
                                return {
                                    label: value.ga + " # " + value.devicename+" # "+value.dpt, // Label for Display
                                    value: value.ga // Value
                                }
                            } else {
                                return null;
                            }
                        }));
                    });
                },select: function(event, ui) {
                    // Sets Datapoint and device name automatically
                    $('#node-input-name').val(ui.item.label.split("#")[1].trim());
                    var optVal = $("#node-input-dpt option:contains('"+ui.item.label.split("#")[2].trim()+"')").attr('value');
                    // Select the option value 
                    $("#node-input-dpt").val(optVal);
                }
              });

            // Hide or show the GA and DPT fields if Notify on all Group Addresses is checked
            if(this.server){
                if (typeof RED.nodes.node(this.server).csv !== 'undefined' && RED.nodes.node(this.server).csv!="") {
                    //$("#node-input-listenallga").prop("disabled", false);
                    $("#helpallga").hide()
                 }else{
                    //$("#node-input-listenallga").prop("disabled", true);
                    $("#node-input-listenallga").prop("checked", false)
                    $("#GAandDPT").show()
                    $("#helpallga").show()
                }
            }else{
                //$("#node-input-listenallga").prop("disabled", true);
                $("#node-input-listenallga").prop("checked", false)
                $("#GAandDPT").show()
                $("#helpallga").show()
            }
        },
        oneditsave: function(){
             // Uncheck the Listen All GA's if the config node doesn't contain the csv
             if(this.server){
                if (typeof RED.nodes.node(this.server).csv !== 'undefined' && RED.nodes.node(this.server).csv!="") {
                }else{
                   
                    // Notify the user
                     if($("#node-input-listenallga").is(":checked")){
                        var checkResult="Listen to all Group Addresses needs a valid ETS csv. Please paste the ETS csv in the config node."
                        var myNotification= RED.notify(checkResult,
                        {
                            modal: true,
                            fixed: true,
                            type: 'error',
                            buttons: [
                                {
                                    text: "OK",
                                    click: function(e) {
                                        myNotification.close();
                                    }
                                }]
                        })
                    }
                    //$("#node-input-listenallga").prop("disabled", true);
                    $("#node-input-listenallga").prop("checked", false)
                    $("#GAandDPT").show()
                    $("#helpallga").show()
                }
            }else{
                //$("#node-input-listenallga").prop("disabled", true);
                $("#node-input-listenallga").prop("checked", false)
                $("#GAandDPT").show()
                $("#helpallga").show()
            }
        }

        
    })
    
</script>

<script type="text/x-red" data-template-name="knxUltimate">
   
    <div class="form-row">
        <label for="node-input-server"><i class="fa fa-tag"></i> Gateway </label>
        <input type="text" id="node-input-server">
    </div>
    <div id="GAandDPT">
        <div class="form-row">
            <label for="node-input-topic"><i class="fa fa-tasks"></i> Group Address (topic)</label>
            <input type="text" id="node-input-topic" placeholder="Ex: 1/1/1 or select 'Listen to all Groups'">
        </div>
        <div class="form-row">
            <label for="node-input-dpt"><i class="fa fa-tasks"></i> Datapoint </label>
            <select id="node-input-dpt"></select>
        </div>
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name </label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
        <div class="form-row">
                <input type="checkbox" id="node-input-listenallga" style="display:inline-block; width:auto; vertical-align:top;">
                <label style="width:auto" for="node-input-listenallga"> Listen to all Group Addresses (using ETS file)</label>
                <div id="helpallga"><i>   You must import your ETS file, otherwise this option is disabled.<br />Please see the config node. <br />Once imported, please click deploy to enable this option</i></div>
        </div>
    
    <dt>OUTPUT (sends datagram to the KNX bus)</dt>
    <div class="form-row">
        <label for="node-input-outputtype"> Output Type </label>
        <select id="node-input-outputtype">
            <option value="write">Write</option>
            <option value="response">Response</option>
        </select>
    </div>
    <dd>
        <div class="form-row">
            <input type="checkbox" id="node-input-inputRBE" style="display:inline-block; width:auto; vertical-align:top;">
            <label style="width:auto" for="node-input-inputRBE"> RBE filter - only passes on data to KNX bus if the payload has changed</label>
            <div id="helpallga"><i>  The RBE (Report by Exception) filter, writes to KNX bus only if the received <b>msg.payload</b><br/> differs from the current value.<br/>For example, if the <i>kitchen light</i> is on (true) and you send again a msg.payload=true to the node,<br/>the value will not be written again to the bus. This is useful to avoid loops.</i></div>
        </div>
    </dd>
    <dd>
        <div class="form-row">
            <input type="checkbox" id="node-input-initialread" style="display:inline-block; width:auto; vertical-align:top;">
            <label style="width:auto" for="node-input-initialread"> Send a GroupValue read once on connection/reconnect </label>
        </div>
    </dd>
   
    <dt>INPUT (listen to datagram from the KNX bus)</dt>
        <dd>
            <div class="form-row">
            <input type="checkbox" id="node-input-notifywrite" style="display:inline-block; width:auto; vertical-align:top;">
            <label style="width:auto" for="node-input-notifywrite"> React to event GroupValue write </label>
            </div>
        </dd>
        <dd>
            <div class="form-row">
            <input type="checkbox" id="node-input-notifyresponse" style="display:inline-block; width:auto; vertical-align:top;">
            <label style="width:auto" for="node-input-notifyresponse"> React to event GroupValue response </label>
            </div>
        </dd>
        <dd>
            <div class="form-row">
            <input type="checkbox" id="node-input-notifyreadrequest" style="display:inline-block; width:auto; vertical-align:top;">
            <label style="width:auto" for="node-input-notifyreadrequest"> React to event GroupValue read </label>
            </div>
        </dd>
</script>

<script type="text/x-red" data-help-name="knxUltimate">
    <p>
        Knx-ultimate is a powerfull device node, all-in-one. It acts as input device as well as output device at the same time.<br />
        Please see the <a href="https://github.com/Supergiovane/node-red-contrib-knx-ultimate/wiki">WIKI for instructions.</a>.<br />
        You can import your ETS csv file, containing all your group addresses and datapoint types and use it instead of manually create one node for each group address.<br />
        Node's settings is divided in 3 parts: common settings, input settings (Node used as input device) and output settings (Node used as output device).
    </p>
         <p>
            <h3>COMMON SETTINGS</h3>
            <dl class="message-properties">
                <dt>Gateway</dt>
                <dd> Selected KNX gateway. </dd>
 
                <dt>Group Address (topic)
                    <span class="property-type">Example 0/0/1</span>
                </dt>
                <dd> KNX Group address to read/write to. It's not mandatory if you import the ETS csv file and select <i>Listen to all Group Addresses (using ETS file)</i>. Please note that the Group Address will then transmitted to the flow as <code>msg.topic</code>. It can be overridden by <code>msg.knx.destination</code>.</dd>
    
                <dt>Datapoint</dt>
                <dd> KNX datapoint type (DPT). It's not mandatory if you import the ETS csv file and select <i>Listen to all Group Addresses (using ETS file)</i>. It can be overridden by <code>msg.dpt</code>.</dd>
    
                <dt>Listen to all Group Addresses (using ETS file)</dt>
                <dd> The node will react to all group addresses when used as INPUT, and will notify a message containing a payload correctly decoded using the datapoints specified in the ETS csv file. When used as OUTPUT, it automatically decodes the payload using the right datapoint specified in the ETS csv file.</dd>
            </dl>

            <h3>OUTPUT (sends datagram to the KNX bus)</h3>
            <dl class="message-properties">
                    <dt>Output Type</dt>
                    <dd>Write: the node will send the payload to the KNX bus as a 'write' message (standard).<br />
                        Response: the node will send the payload to the KNX bus as a 'response' message (in case you wish to create your own 'response', in response to a read request).</dd>
        
                    <dt>Send a GroupValue read once on connection/reconnect</dt>
                    <dd>On connection/reconnection, the node will send a 'read' request to the group address specified on the <b>Group Address</b> or, if <i>Listen to all Group Addresses (using ETS file)</i> is selected, on all group addresses specified on the ETS csv file.</dd>

                    <dt>RBE filter - only passes on data to KNX bus if the payload has changed</dt>
                    <dd>The RBE (Report by Exception) filter, only passes on data if the payload has changed. The node writes to KNX bus only if the received msg.payload differs from the current value. For example, if the kitchen light is on (true) and you send again a msg.payload=true to the node, the value will not be written again to the bus. This is useful to avoid loops.</dd>
                </dl>
           
            <h3>INPUT (listen to datagram from the KNX bus)</h3>
            <dl class="message-properties">
                <dt>React to event GroupValue write</dt>
                <dd>When checked, received writeRequests will be notified</dd>

                <dt>React to event GroupValue response</dt>
                <dd>When checked, received responses will be notified</dd>

                <dt>React to event GroupValue read</dt>
                <dd> When checked, received read requests will be notified, this can be used to create your own response with a <i>Output Type</i> set to 'Response'.
                    <strong>Attention:</strong> Messages for received read requests have a <code>msg.payload</code> and
                    <code>msg.knx.rawValue</code> with value <code>null</code>.
                </dd>
            </dl>
        </p>
        

   <p>
        <h3>MSG FORMAT</h3>
        The Node Device accepts input and output. Below, an explanation of the message's format to be sent to or trasmitted from the node.<br /><br />
        <b>YOU CAN SEND THIS TO THE NODE</b><br />
        <code>msg.readstatus=true</code>: Issues a read request to the KNX bus. You'll expect a 'response' from the bus. When you issue a 'read' request, you can only override the group address specified in the <b>Group Address</b>, with <code>msg.destination</code>. If you've selected <i>Listen to all Group Addresses (using ETS file)</i>, the node will issue a 'read' request to ALL group addresses specified in the ETS csv file.<br />
        <code>msg.payload</code>: issues a write or response (based on the options <b>Output Type</b> above) to the KNX bus.<br />
        <code>msg.event</code>: "GroupValue_Write" or "GroupValue_Response", overrides the option <b>Output Type</b> above.<br />
        <code>msg.destination</code>: for example "0/0/1", overrides the node's <b>Group Address</b>.<br />
        <code>msg.dpt</code>: for example "1.001", overrides the <b>Datapoint</b> option. (Datapoints can be sent as 9 , "9" , "9.001" or "DPT9.001")<br />
    </p>
    <p>
        The Node has a circular reference protection. If 2 nodes with same group address are link toghether, the protection avoids loops by stopping the message transmitted to the KNX BUS.
    </p>
    
    <p>
     <b>THE NODE OUTPUTS THIS TO THE FLOW</b><br />
     The node outputs a message with these data (if the node receives a WRITE telegram):
    </p>
<pre>
msg = {
    "topic": "1/1/1",
    "payload": 0,
    "knx": {
        "event": "GroupValue_Write",
        "dpt": "1.001",
    "devicename": "Kitchen Lamp", --only if ETS csv file is used--
    "source": "2.2.2",
    "destination": "1/1/1",
    "rawValue": [0]
    }} </pre>
    <p>
    The node outputs a message with these data (if the node receives a RESPONSE telegram):
    </p>
<pre>msg = {
    "topic": "1/1/1",
    "payload": 0,
    "knx": {
        "event": "GroupValue_Response",
        "dpt":"1.001"
        },
    "devicename": "Kitchen Lamp", --only if ETS csv file is used--
    "source": "2.2.2",
    "destination": "1/1/1",
    "rawValue": [0]
    }} </pre>

    The node outputs a message with these data (if the node receives a READ telegram):
<pre> msg = {
    "topic": "1/1/1",
    "payload": null,
    "knx": {
        "event": "GroupValue_Read",
        "dpt":"1.001"
        },
    "source": "2.2.2",
    "destination": "1/1/1",
    "rawValue": null
    }} </pre>
           
    </script>